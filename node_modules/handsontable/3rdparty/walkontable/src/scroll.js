"use strict";

exports.__esModule = true;
exports.default = void 0;

var _element = require("../../../helpers/dom/element");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * @class Scroll
 */
var Scroll = /*#__PURE__*/function () {
  /**
   * Tha data access object.
   *
   * @protected
   * @type {ScrollDao}
   */

  /**
   * @param {ScrollDao} dataAccessObject Tha data access object.
   */
  function Scroll(dataAccessObject) {
    _classCallCheck(this, Scroll);

    _defineProperty(this, "dataAccessObject", void 0);

    this.dataAccessObject = dataAccessObject;
  }
  /**
   * Scrolls viewport to a cell.
   *
   * @param {CellCoords} coords The cell coordinates.
   * @param {boolean} [snapToTop] If `true`, viewport is scrolled to show the cell on the top of the table.
   * @param {boolean} [snapToRight] If `true`, viewport is scrolled to show the cell on the right of the table.
   * @param {boolean} [snapToBottom] If `true`, viewport is scrolled to show the cell on the bottom of the table.
   * @param {boolean} [snapToLeft] If `true`, viewport is scrolled to show the cell on the left of the table.
   * @returns {boolean}
   */


  _createClass(Scroll, [{
    key: "scrollViewport",
    value: function scrollViewport(coords, snapToTop, snapToRight, snapToBottom, snapToLeft) {
      if (coords.col < 0 || coords.row < 0) {
        return false;
      }

      var scrolledHorizontally = this.scrollViewportHorizontally(coords.col, snapToRight, snapToLeft);
      var scrolledVertically = this.scrollViewportVertically(coords.row, snapToTop, snapToBottom);
      return scrolledHorizontally || scrolledVertically;
    }
    /**
     * Scrolls viewport to a column.
     *
     * @param {number} column Visual column index.
     * @param {boolean} [snapToRight] If `true`, viewport is scrolled to show the cell on the right of the table.
     * @param {boolean} [snapToLeft] If `true`, viewport is scrolled to show the cell on the left of the table.
     * @returns {boolean}
     */

  }, {
    key: "scrollViewportHorizontally",
    value: function scrollViewportHorizontally(column, snapToRight, snapToLeft) {
      if (!this.dataAccessObject.drawn) {
        return false;
      }

      var _this$dataAccessObjec = this.dataAccessObject,
          fixedColumnsStart = _this$dataAccessObjec.fixedColumnsStart,
          inlineStartOverlay = _this$dataAccessObjec.inlineStartOverlay,
          totalColumns = _this$dataAccessObjec.totalColumns;
      var result = false;

      if (column >= 0 && column <= Math.max(totalColumns - 1, 0)) {
        var firstVisibleColumn = this.getFirstVisibleColumn();
        var lastVisibleColumn = this.getLastVisibleColumn();

        if (column >= fixedColumnsStart && firstVisibleColumn > -1 && (column < firstVisibleColumn || snapToLeft)) {
          result = inlineStartOverlay.scrollTo(column);
        } else if (lastVisibleColumn === -1 || lastVisibleColumn > -1 && (column > lastVisibleColumn || snapToRight)) {
          result = inlineStartOverlay.scrollTo(column, true);
        }
      }

      return result;
    }
    /**
     * Scrolls viewport to a row.
     *
     * @param {number} row Visual row index.
     * @param {boolean} [snapToTop] If `true`, viewport is scrolled to show the cell on the top of the table.
     * @param {boolean} [snapToBottom] If `true`, viewport is scrolled to show the cell on the bottom of the table.
     * @returns {boolean}
     */

  }, {
    key: "scrollViewportVertically",
    value: function scrollViewportVertically(row, snapToTop, snapToBottom) {
      if (!this.dataAccessObject.drawn) {
        return false;
      }

      var _this$dataAccessObjec2 = this.dataAccessObject,
          fixedRowsBottom = _this$dataAccessObjec2.fixedRowsBottom,
          fixedRowsTop = _this$dataAccessObjec2.fixedRowsTop,
          topOverlay = _this$dataAccessObjec2.topOverlay,
          totalRows = _this$dataAccessObjec2.totalRows;
      var result = false;

      if (row >= 0 && row <= Math.max(totalRows - 1, 0)) {
        var firstVisibleRow = this.getFirstVisibleRow();
        var lastVisibleRow = this.getLastVisibleRow();

        if (row >= fixedRowsTop && firstVisibleRow > -1 && (row < firstVisibleRow || snapToTop)) {
          result = topOverlay.scrollTo(row);
        } else if (lastVisibleRow === -1 || lastVisibleRow > -1 && (row > lastVisibleRow && row < totalRows - fixedRowsBottom || snapToBottom)) {
          result = topOverlay.scrollTo(row, true);
        }
      }

      return result;
    }
    /**
     * Get first visible row based on virtual dom and how table is visible in browser window viewport.
     *
     * @returns {number}
     */

  }, {
    key: "getFirstVisibleRow",
    value: function getFirstVisibleRow() {
      var _this$dataAccessObjec3 = this.dataAccessObject,
          topOverlay = _this$dataAccessObjec3.topOverlay,
          wtTable = _this$dataAccessObjec3.wtTable,
          wtViewport = _this$dataAccessObjec3.wtViewport,
          totalRows = _this$dataAccessObjec3.totalRows,
          fixedRowsTop = _this$dataAccessObjec3.fixedRowsTop,
          rootWindow = _this$dataAccessObjec3.rootWindow;
      var firstVisibleRow = wtTable.getFirstVisibleRow();

      if (topOverlay.mainTableScrollableElement === rootWindow) {
        var rootElementOffset = (0, _element.offset)(wtTable.wtRootElement);
        var totalTableHeight = (0, _element.innerHeight)(wtTable.hider);
        var windowHeight = (0, _element.innerHeight)(rootWindow);
        var windowScrollTop = (0, _element.getScrollTop)(rootWindow, rootWindow); // Only calculate firstVisibleRow when table didn't filled (from up) whole viewport space

        if (rootElementOffset.top + totalTableHeight - windowHeight <= windowScrollTop) {
          var rowsHeight = wtViewport.getColumnHeaderHeight();
          rowsHeight += topOverlay.sumCellSizes(0, fixedRowsTop);

          for (var row = totalRows; row > 0; row--) {
            rowsHeight += topOverlay.sumCellSizes(row - 1, row);

            if (rootElementOffset.top + totalTableHeight - rowsHeight <= windowScrollTop) {
              // Return physical row + 1
              firstVisibleRow = row;
              break;
            }
          }
        }
      }

      return firstVisibleRow;
    }
    /**
     * Get last visible row based on virtual dom and how table is visible in browser window viewport.
     *
     * @returns {number}
     */

  }, {
    key: "getLastVisibleRow",
    value: function getLastVisibleRow() {
      var _this$dataAccessObjec4 = this.dataAccessObject,
          topOverlay = _this$dataAccessObjec4.topOverlay,
          wtTable = _this$dataAccessObjec4.wtTable,
          wtViewport = _this$dataAccessObjec4.wtViewport,
          totalRows = _this$dataAccessObjec4.totalRows,
          rootWindow = _this$dataAccessObjec4.rootWindow;
      var lastVisibleRow = wtTable.getLastVisibleRow();

      if (topOverlay.mainTableScrollableElement === rootWindow) {
        var rootElementOffset = (0, _element.offset)(wtTable.wtRootElement);
        var windowScrollTop = (0, _element.getScrollTop)(rootWindow, rootWindow); // Only calculate lastVisibleRow when table didn't filled (from bottom) whole viewport space

        if (rootElementOffset.top > windowScrollTop) {
          var windowHeight = (0, _element.innerHeight)(rootWindow);
          var rowsHeight = wtViewport.getColumnHeaderHeight();

          for (var row = 1; row <= totalRows; row++) {
            rowsHeight += topOverlay.sumCellSizes(row - 1, row);

            if (rootElementOffset.top + rowsHeight - windowScrollTop >= windowHeight) {
              // Return physical row - 1 (-2 because rangeEach gives row index + 1 - sumCellSizes requirements)
              lastVisibleRow = row - 2;
              break;
            }
          }
        }
      }

      return lastVisibleRow;
    }
    /**
     * Get first visible column based on virtual dom and how table is visible in browser window viewport.
     *
     * @returns {number}
     */

  }, {
    key: "getFirstVisibleColumn",
    value: function getFirstVisibleColumn() {
      var _this$dataAccessObjec5 = this.dataAccessObject,
          inlineStartOverlay = _this$dataAccessObjec5.inlineStartOverlay,
          wtTable = _this$dataAccessObjec5.wtTable,
          wtViewport = _this$dataAccessObjec5.wtViewport,
          totalColumns = _this$dataAccessObjec5.totalColumns,
          rootWindow = _this$dataAccessObjec5.rootWindow;
      var firstVisibleColumn = wtTable.getFirstVisibleColumn();

      if (inlineStartOverlay.mainTableScrollableElement === rootWindow) {
        var rootElementOffset = (0, _element.offset)(wtTable.wtRootElement);
        var totalTableWidth = (0, _element.innerWidth)(wtTable.hider);
        var windowWidth = (0, _element.innerWidth)(rootWindow);
        var windowScrollLeft = Math.abs((0, _element.getScrollLeft)(rootWindow, rootWindow)); // Only calculate firstVisibleColumn when table didn't filled (from left) whole viewport space

        if (rootElementOffset.left + totalTableWidth - windowWidth <= windowScrollLeft) {
          var columnsWidth = wtViewport.getRowHeaderWidth();

          for (var column = totalColumns; column > 0; column--) {
            columnsWidth += inlineStartOverlay.sumCellSizes(column - 1, column);

            if (rootElementOffset.left + totalTableWidth - columnsWidth <= windowScrollLeft) {
              // Return physical column + 1
              firstVisibleColumn = column;
              break;
            }
          }
        }
      }

      return firstVisibleColumn;
    }
    /**
     * Get last visible column based on virtual dom and how table is visible in browser window viewport.
     *
     * @returns {number}
     */

  }, {
    key: "getLastVisibleColumn",
    value: function getLastVisibleColumn() {
      var _this$dataAccessObjec6 = this.dataAccessObject,
          inlineStartOverlay = _this$dataAccessObjec6.inlineStartOverlay,
          wtTable = _this$dataAccessObjec6.wtTable,
          wtViewport = _this$dataAccessObjec6.wtViewport,
          totalColumns = _this$dataAccessObjec6.totalColumns,
          rootWindow = _this$dataAccessObjec6.rootWindow;
      var lastVisibleColumn = wtTable.getLastVisibleColumn();

      if (inlineStartOverlay.mainTableScrollableElement === rootWindow) {
        var rootElementOffset = (0, _element.offset)(wtTable.wtRootElement);
        var windowScrollLeft = Math.abs((0, _element.getScrollLeft)(rootWindow, rootWindow)); // Only calculate lastVisibleColumn when table didn't filled (from right) whole viewport space

        if (rootElementOffset.left > windowScrollLeft) {
          var windowWidth = (0, _element.innerWidth)(rootWindow);
          var columnsWidth = wtViewport.getRowHeaderWidth();

          for (var column = 1; column <= totalColumns; column++) {
            columnsWidth += inlineStartOverlay.sumCellSizes(column - 1, column);

            if (rootElementOffset.left + columnsWidth - windowScrollLeft >= windowWidth) {
              // Return physical column - 1 (-2 because rangeEach gives column index + 1 - sumCellSizes requirements)
              lastVisibleColumn = column - 2;
              break;
            }
          }
        }
      }

      return lastVisibleColumn;
    }
  }]);

  return Scroll;
}();

var _default = Scroll;
exports.default = _default;